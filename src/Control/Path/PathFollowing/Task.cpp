//***************************************************************************
// Copyright 2007-2015 Universidade do Porto - Faculdade de Engenharia      *
// Laboratório de Sistemas e Tecnologia Subaquática (LSTS)                  *
//***************************************************************************
// This file is part of DUNE: Unified Navigation Environment.               *
//                                                                          *
// Commercial Licence Usage                                                 *
// Licencees holding valid commercial DUNE licences may use this file in    *
// accordance with the commercial licence agreement provided with the       *
// Software or, alternatively, in accordance with the terms contained in a  *
// written agreement between you and Universidade do Porto. For licensing   *
// terms, conditions, and further information contact lsts@fe.up.pt.        *
//                                                                          *
// European Union Public Licence - EUPL v.1.1 Usage                         *
// Alternatively, this file may be used under the terms of the EUPL,        *
// Version 1.1 only (the "Licence"), appearing in the file LICENCE.md       *
// included in the packaging of this file. You may not use this work        *
// except in compliance with the Licence. Unless required by applicable     *
// law or agreed to in writing, software distributed under the Licence is   *
// distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF     *
// ANY KIND, either express or implied. See the Licence for the specific    *
// language governing permissions and limitations at                        *
// http://ec.europa.eu/idabc/eupl.html.                                     *
//***************************************************************************
// Author: Praveen Jain                                                     *
//***************************************************************************

// DUNE headers.
#include <DUNE/DUNE.hpp>

namespace
{
  namespace Control
  {
    namespace Path
    {
      namespace PathFollowing
      {
	using DUNE_NAMESPACES;

	struct Task: public DUNE::Control::PathFollowing
	{
	  // Vehicle Commands generated by Path Following Controller
	  IMC::DesiredZ m_altitude_cmd; 		             // Desired Altitude in meters
	  IMC::DesiredHeadingRate m_heading_rate_cmd;    // Desired heading rate
	  IMC::DesiredSpeed m_speed_cmd;                 // Desired speed command(body coordinates)
	  IMC::PathFollowState m_pathfollow_state;       // Logdata
	  IMC::DesiredHeading m_heading_cmd;             // Desired heading

	  struct ControlParams
	  {
	    fp32_t dt;         // Control period
	    fp64_t epsilon;    // epsilon error
	    fp32_t kx_gain;    // Control gain for ex
      fp32_t ky_gain;    // Control gain for ey
	    Matrix delta_inv;  // Inverse of delta matrix
      Matrix Kp;         // Gain matrix composed for kx_gain and ky_gain
	  } m_control_params;

	  struct ControlReferences
	  {
	    double speed;  // Along track desired  speed reference (longitudinal velocity)
	    double x;      // Desired x
	    double y;      // Desired y
	    double z;      // Desired z - 0 for 2D case
	    double vx;     // Desired vx (NED)
	    double vy;     // Desired vy (NED)
	    double vz;     // Desired vz (NED)
	  } m_control_ref;

	  struct ControlVariables
	  {
	    fp64_t gamma; 		// Path variable or coordination state
	  } m_control_var;

	  //! Constructor.
	  //! @param[in] name task name.
	  //! @param[in] ctx context.
	  Task(const std::string& name, Tasks::Context& ctx):
	    DUNE::Control::PathFollowing(name, ctx)
	  {
	    param("Kx Gain", m_control_params.kx_gain)
      .defaultValue("1.0")
      .description("Controller gain - ex");

      param("Ky Gain", m_control_params.ky_gain)
      .defaultValue("1.0")
      .description("Controller gain - ex");

	    param("Bound Epsilon", m_control_params.epsilon)
	    .defaultValue("0.3")
	    .description("Bound around the path in meters");

	    param("Control Period", m_control_params.dt)
	    .defaultValue("0.1")
	    .description("Sampling period in seconds");

	    param("Desired Speed", m_control_ref.speed)
	    .defaultValue("0.3")
	    .description("Speed in m/s");

	  }

	  //! Update internal state with new parameter values.
	  void
	  onUpdateParameters(void)
	  {
	    // parameters were set
	    PathFollowing::onUpdateParameters();

      // Necessary variables for control computation
      double temp_delta[4] = {1.0, 0.0, 0.0, m_control_params.epsilon};
      Matrix delta(temp_delta, 2, 2);
      m_control_params.delta_inv = inverse(delta);

      double temp_gain[4] = {m_control_params.kx_gain, 0.0, 0.0, m_control_params.ky_gain};
      Matrix gain_matrix(temp_gain, 2, 2);
      m_control_params.Kp = gain_matrix;

      // Initialize the Controller variables
     m_control_var.gamma = 0.0;

     // Initialize the reference variables
     m_control_ref.x = 0.0;
     m_control_ref.y = 0.0;
     m_control_ref.z = 0.0;
     m_control_ref.vx = 0.0;
     m_control_ref.vy = 0.0;
     m_control_ref.vz = 0.0;
	  }

	  void
	  onPathActivation(void)
	  {
	  }

	  void
	  onPathStartup(const IMC::EstimatedState& state, const TrackingState& ts)
	  {
	    //Reset gamma here, do things needed when new path has started
	    m_control_var.gamma = 0.0;
	    //std::cout << "Gamma PS " << m_control_var.gamma << std::endl;
	  }

	  void
	  onDesiredSpeedReference(IMC::DesiredSpeed& speed)
	  {
	    //m_control_ref.speed = speed.value;
	    // m_control_ref.speed = 1.0;
	  }

	  //! Main loop.
	  void
	  step(const IMC::EstimatedState& state, const TrackingState& ts)
	  {

	    // Step 1: Compute the desired reference position and update gamma

	    m_control_ref.x = ts.start.x + m_control_var.gamma*std::cos((ts.track_bearing));
	    m_control_ref.y = ts.start.y + m_control_var.gamma*std::sin((ts.track_bearing));
	    m_control_ref.vx = m_control_ref.speed*std::cos((ts.track_bearing));
	    m_control_ref.vy = m_control_ref.speed*std::sin((ts.track_bearing));
	    m_control_var.gamma += ts.delta*m_control_ref.speed;

	    // Step 2: Compute the error

	    double error_values[] = {(state.x - m_control_ref.x), (state.y - m_control_ref.y)};
	    double rot_values[] = {std::cos(ts.course), -std::sin(ts.course), std::sin(ts.course), std::cos(ts.course)};
	    double pd_dot_values[] = {m_control_ref.vx, m_control_ref.vy};
	    double eps_vector[] = {(double)m_control_params.epsilon, 0.0};
	    Matrix error_world(error_values,2,1);
	    Matrix R(rot_values,2,2);
	    Matrix Eps(eps_vector, 2,1);
	    Matrix Pd_dot(pd_dot_values,2,1);
	    Matrix error_body(2,1,(double)0.0);

	    error_body = transpose(R)*error_world + Eps;

	    // Step 3: Compute control input
      double tanh_ex = tanh(error_body.element(0,0));
      double tanh_ey = tanh(error_body.element(1,0));
      double tanh_e_vector[] = {tanh_ex, tanh_ey};
      Matrix tanh_e(tanh_e_vector,2,1);
	    Matrix control_cmd(2,1,(double)0.0);
      // Path Following controller 1: without saturation in control law
      control_cmd = m_control_params.delta_inv*(-m_control_params.Kp*error_body + transpose(R)*Pd_dot);
      // Path Following controller 2: with saturation in terms of tanh
	    // control_cmd = m_control_params.delta_inv*(-m_control_params.Kp*tanh_e + transpose(R)*Pd_dot);

	    //Logdata
	    m_pathfollow_state.gamma = m_control_var.gamma;
	    m_pathfollow_state.gamma_dot = m_control_ref.speed;
	    m_pathfollow_state.x = m_control_ref.x;
	    m_pathfollow_state.y = m_control_ref.y;
	    m_pathfollow_state.z = 0.0;
	    m_pathfollow_state.vx = m_control_ref.vx;
	    m_pathfollow_state.vy = m_control_ref.vy;
	    m_pathfollow_state.vz = 0.0;
	    // m_pathfollow_state.err_x = state.x - m_control_ref.x;
	    // m_pathfollow_state.err_y = state.y - m_control_ref.y;
      m_pathfollow_state.err_x = error_body.element(0,0);
      m_pathfollow_state.err_y = error_body.element(1,0);
	    m_pathfollow_state.err_z = 0.0;
	    m_pathfollow_state.start_x = ts.start.x;
	    m_pathfollow_state.start_y = ts.start.y;
	    m_pathfollow_state.start_z = ts.start.z;
	    m_pathfollow_state.end_x = ts.end.x;
	    m_pathfollow_state.end_y = ts.end.y;
	    m_pathfollow_state.end_z = ts.end.z;
	    m_pathfollow_state.track_bearing = ts.track_bearing;


	    // Step 4: Dispatch control commands
	    m_speed_cmd.value = bound(control_cmd.element(0,0), -1.0, 2.0);
	    m_heading_rate_cmd.value = bound(control_cmd.element(1,0), -0.5, 0.5);

	    enableControlLoops(IMC::CL_SPEED);
	    enableControlLoops(IMC::CL_YAW_RATE);

	    dispatch(m_speed_cmd,Tasks::DF_LOOP_BACK);
	    dispatch(m_heading_rate_cmd);

      // Step 5: Dispatch Log data
	    dispatch(m_pathfollow_state);

	  } // End of step

	  static double bound(double value, double min, double max)
	  {
	    return (value < min) ? min : (value > max) ? max : value;
	  }
	}; // end - Class
      } //end - namespace PathFollowing
    } //end - namespace Path
  } // end - namespace Control
} //end - namespace

DUNE_TASK
